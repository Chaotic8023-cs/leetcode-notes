# 123
from typing import *
from utils.pprintdp import pprintdp


class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        n = len(prices)
        dp = [[0]*4 for _ in range(n)]

        """
        最多买两次
        dp[i][0]: 持有（第一次）
        dp[i][1]: 不持有（第一次）
        dp[i][2]: 持有（第二次）
        dp[i][3]: 不持有（第二次）
        因为最陡买两次，所以这题中以上含义是有先后顺序的 (0->1->2->3)！
        如第一次不持有只能是买过第一次之后的（或前一天还是第一次不持有),
        第二次不持有只能是第二次买过之后的（或前一天还是第二次不持有），
        第二次持有的状态前一天要么是已经在第二次持有，要么是第一次不持有（第一次卖掉后）状态！
        
        因为这里存在先后顺序，第一次持有只能是还没操作（所有状态之前的状态，利润为0）过来的
        而不是第一次不持有，因为第一次不持有只能是第一次持有后卖掉转变过来的
        但是还没操作的话利润还是初始值0，所以第一次持有如果是还没操作转变过来，就相当于进行了第一次买入，
        即利润为-prices[i]。
        
        相当于省略了一个dp维度：还没操作）：
        dp[i][x] = dp[i-1][x]，今天还没操作说明昨天也没操作
        但是因为这个状态只能转移到第一次持有，所以可以省略，
        即把
            dp[i][0] = max(dp[i-1][0], dp[i-1][x]-prices[i])
        替换为
            dp[i][0] = max(dp[i-1][0], -prices[i])
        因为dp[i-1][x]为0（所有还没操作的利润都为0）。
        """
        dp[0][0] = -prices[0]   # 第一天直接买入
        dp[0][1] = 0            # 第一天买了在卖
        dp[0][2] = -prices[0]   # 第一天买了在卖，再买如第二次
        dp[0][3] = 0            # 第一天买了在卖，再第二次买了在卖
        """
        初始化也遵循先后顺序，因为递推公式是按顺序的，就保证了先后性。
        """
        for i in range(1, n):
            # 第一次持有的前一天：1. 也是第一次持有， 2. 还没开始操作，也相当于今天直接第一次买入
            dp[i][0] = max(dp[i-1][0], -prices[i])
            # 第一次不持有的前一天：1. 也是第一次不持有， 2. 第一次持有 -> 今天第一次卖出
            dp[i][1] = max(dp[i-1][1], dp[i-1][0]+prices[i])
            # 第二次持有的前一天：1. 也是第二次持有， 2. 第一次不持有 -> 今天第二次买入
            dp[i][2] = max(dp[i-1][2], dp[i-1][1]-prices[i])
            # 第二次不持有的前一天：1. 也是第二次不持有， 2. 第二次持有 -> 今天第二次卖出
            dp[i][3] = max(dp[i-1][3], dp[i-1][2]+prices[i])
        pprintdp(dp)
        """
        只用选第二次卖出的利润，因为第二次卖出一定大于第一次卖出的利润
        因为我们一直找最大值，即求最优解，如果第一次卖出就已经是最大利润了，
        则第二次卖出在dp里也是最大利润（相当于第二次在同一天买了又卖了一遍，可以理解为等效了）。
        给定一个i，即一个subarray，dp能保证0到i是正确可解释的。
        如果这想不明白，可以打印出来dp数组看看。
        实在不行return个第一次不持有和第二次不持有的最大值也是对的，只是如果第一次卖掉
        就是最优解的话，第二次卖掉的利润和第一次就会相同:
        return max(dp[n-1][1], dp[n-1][3])
        """
        return dp[n-1][3]


if __name__ == '__main__':
    prices = [3, 3, 5, 0, 0, 3, 1, 4]
    # 下面就是第一次不持有就是最优解的情况
    # prices = [2, 1, 9, 8, 7]
    sol = Solution()
    print(sol.maxProfit(prices))

