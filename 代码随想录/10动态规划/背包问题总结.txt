01背包：
1. 基础：  # 卡码46
    2d：
        > 初始化：物品背包全部多一个维度，全部初始化成0即可
        > 遍历：物品从第一个物品开始，index从1开始（不用管第0行）；背包从0开始（要管第0列）
    1d：
        > 初始化：同2d，但只有背包（背包容量加一个容量为0的）
        > 遍历：物品正序，从第一个物品开始，但是此时下标就可以从0开始；背包倒序（防止物品复用），范围[capacity, weight[i]]

    注意：如果物品index从1开始，那么访问weight和value数组就要i-1！

2. 变种：
    (1) 装满背包有几种方法[求方法个数]：  # 494目标和
        递推公式：不选和选的方法数之和，类似爬楼梯的思想
        2d：
            > 初始化：同基础01背包物品背包都加一个维度且全初始化成0，但额外的 -> dp[0][0] = 1
            > 遍历：同基础版
        1d：
            > 初始化：同基础01背包物品背包都加一个维度且全初始化成0，但额外的 -> dp[0] = 1
            > 遍历：同基础版
    (2) 背包维度变多（即有不同种类的“容量”，但还是1个背包）  # 474一和零
        递推公式：和基础版本一样，但背包容量加一个维度，也就是背包有两个for循环
        2d：
            > 初始化：同基础01背包物品背包都加一个维度且全初始化成0，但额外的 -> dp[0][0] = 1
            > 遍历：同基础版，物品从第一个开始（下标从1开始，忽略0行）；背包两个维度都从0开始（不忽略第0列）
        注意：由于背包有两个不同的维度，对应物品两种不同的重量，所以选当前物品的条件是两种重量都满足当前背包的容量！
        补充：#474题还用到一个思想就是求最多物品数时我们可以设每个物品的价值都是1，然后题目就转化成一般的求最大价值！


完全背包：
1. 基础：  # 卡码52
    递推公式的差异：
    01背包：
        dp[i][j] = max(dp[i][j], dp[i - 1][j - weight[i - 1]] + value[i - 1])
    完全背包：
        dp[i][j] = max(dp[i][j], dp[i][j - weight[i - 1]] + value[i - 1])
    我们能发现多重背包里因为能复选，所以是dp[i][j - weight[i - 1]]，即包含物品i但重量少一个物品i，意思是我们已经取了几个
    物品i我们现在还想在取一个！

    2d：
        > 初始化：同01背包，物品背包全部多一个维度，全部初始化成0即可
        > 遍历：同01背包，物品从第一个物品开始，index从1开始（不用管第0行）；背包从0开始（要管第0列）
    1d：
        > 初始化：同01背包1d，只有背包容量且加上一个容量为0的
        > 遍历：物品正序，从第一个物品开始，但是此时下标就可以从0开始；背包正序（物品可以复用），范围[weight[i],capacity]

    注意：如果物品index从1开始，那么访问weight和value数组就要i-1！

2. 变种：
    (1) 装满背包有几种方法[求方法个数]：  # 518零钱兑换2，# 377组合总和4
        递推公式：同01背包的变种(1)，即不选和选的方法数之和，但因为完全背包要复选，所以选当前物品的时候要用dp[i]
        遍历顺序（看题目求的不同方法指不同组合还是不同排列）：先物品后背包 -> 组合；先背包后物品 -> 排列
            组合：同完全背包2d
            排列：不知道为啥直接调换循环顺序行不通，所以记1d即可。同基础完全背包1d，但调换了循环，即先背包后物品。此时先背包没法获得当前物品
                的重量，所以背包从0开始遍历，下面只考虑能装下物品的情况。
        2d：
            > 初始化：同完全背包2d，但因为求方法个数所以dp[0][0] = 1
        1d：
            > 初始化：同完全包1d，但因为求方法个数所以dp[0] = 1

    (2) 求装满背包最小的物品个数：  # 322零钱兑换，# 279完全平方数
        递推公式：min(dp[i-1][j], dp[i][j - coins[i - 1]] + 1)，即不选当前的硬币i，和选当前的物品i（注意复用，所以用dp[i]）
        2d：
        > 初始化：同完全背包2d，但因为求最小物品数所以dp[0][0] = 0
        > 遍历：同完全背包2d，正序
        1d：
        > 初始化：同完全背包2d，但因为求最小物品数所以dp[0] = 0
        > 遍历：同完全背包1d，正序


