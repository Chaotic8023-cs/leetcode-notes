from typing import *


"""
1. dp数组下标含义：dp[i][j]表示[i,j]（左闭右闭）区间内最长的回文子序列的长度
2. 递推公式：此题j严格>i，因为i == j的情况是初始化了的，且我们看的是长度不是个数，我们就分两种情况
    1.  s[i] == s[j]： dp[i][j] = dp[i + 1][j - 1] + 2
        即两头相等，那么就是中间部分的最长回文子序列长度 + 两头这两个字母
    2. s[i] != s[j]：dp[i][j] = max(dp[i + 1][j], dp[i][j - 1])
        两头不等，因为回文是由内向往扩展，那我们就两头各缩一个然后取最大即可
3. 初始化：因为我们不是像#647统计个数那样，i==j的情况算作一个，这里我们就初始化中心点，然后只看j和i差1及以上的区间即可。
    于是我们就初始化所有中间点，即1个字母的情况，也就是i == j时，一个字母也是回文，长度为1
4. 遍历顺序：根据递推公式，dp[i][j]可以由左下，左，右推导而来，所以还和#647回文子串的动规法一样，从下往上从左到右遍历，即i倒序j正序

补充：
循环第一个if其实应当写成：
    if j - i == 1:
        dp[i][j] = 2
    else:
        dp[i][j] = dp[i + 1][j - 1] + 2
因为j比i大1的情况下，比如dp[1][2]在ij各往中间一格的情况下会成dp[2][1]。因为根据定义只有j >= i时有意义，所以dp[2][1]无意义，但又因为
dp数组初始值都是0，所以此时恰好解决了j比i大1时的情况，结果刚好是0+2 = 2！
"""
class Solution:
    def longestPalindromeSubseq(self, s: str) -> int:
        n = len(s)
        # 初始化
        dp = [[0] * n for _ in range(n)]
        for i in range(n):  # 由于回文的递推公式中都是从中间向两边，于是我们就得初始化中间的元素，即i == j的情况，也就是主对角线上的元素都是长度为1的回文子串
            dp[i][i] = 1
        # 遍历：根据递推公式看，dp[i][j]可以由左下，左，右推导而来，所以还和#647回文子串的动规法一样，从下往上从左到右遍历，即i倒序j正序
        for i in range(n - 1, -1, -1):
            for j in range(i + 1, n):  # j > i：j严格大于i，因为我们已经把i == j的情况初始化了
                if s[i] == s[j]:
                    dp[i][j] = dp[i + 1][j - 1] + 2  # 即中间部分的最大长度加上两头两个字母
                    # 对于j = i + 1的情况，即两个字母挨着，dp[i + 1][j - 1]中左就大于右了，不符合dp数组下标含义，但是因为初始化都是0，所以刚好满足这里：dp[i + 1][j - 1] = 0
                else:
                    dp[i][j] = max(dp[i + 1][j], dp[i][j - 1])  # 两头两个字母中的一个往中间退一格
        # 最后返回[0,n-1]范围中的最长回文子序列的长度
        return dp[0][n - 1]

    """
    其实我们也可以不初始化对角线，这样遍历的时候j就得从i开始，加入i == j的情况！
    """
    def longestPalindromeSubseq1(self, s: str) -> int:
        n = len(s)
        dp = [[0] * n for _ in range(n)]
        for i in range(n - 1, -1, -1):
            for j in range(i, n):  # j从i开始，考虑i == j的情况，即一个字母（对角线）
                if s[i] == s[j]:
                    if j - i == 0:  # i == j，即对角线，一个字母的情况
                        dp[i][j] = 1
                    else:
                        dp[i][j] = dp[i + 1][j - 1] + 2
                else:
                    dp[i][j] = max(dp[i + 1][j], dp[i][j - 1])
        return dp[0][n - 1]





