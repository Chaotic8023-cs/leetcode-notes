from typing import *


# Definition for a binary tree node.
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right


class Solution:
    """
    贪心：因为尽可能的少安装摄像头，且树中叶子节点数量多，所以我们应该尽可能的把摄像头安装在叶子节点的上一层。所以我们从下往上进行安装，即用
    后续遍历。我们用两个子树的状态来确定父节点的状态。一个节点有三种状态：
        0：有覆盖
        1：无覆盖
        2：有摄像头
    注意，无摄像头其实就是状态0或1，所以一共就三种状态！
    那么根据子节点的情况来决定父节点的状态：
        1. 左右子节点都有覆盖：则父节点无覆盖。我们希望把摄像头安装在父节点的父节点上以达到最大利用效率（因为安到父节点的父节点上既能覆盖掉父节点，还能覆盖掉再上一层的节点）
            还能这么理解：因为我们从下网上放摄像头，且想把摄像头放到叶子节点的父节点一层，所以我们让base case（叶子节点的左右子节点，也就是None）返回有覆盖，这样
            叶子节点就是情况1，会返回无覆盖，最后摄像头就会安装到叶子节点的父节点上！
        2，左右子节点至少一个无覆盖：则父节点需要安装摄像头，因为要覆盖那个没被覆盖的子节点
        3. 左右子节点至少一个有摄像头：则父节点有覆盖，因为这个摄像头能覆盖掉当前节点。
    最后还得注意，因为我们是从下往上安装摄像头，所以会遇到如果跟节点的两个子节点被覆盖了的话，跟节点就是无覆盖情况，理论上我们应该按第一种情况
    给跟节点的父节点处安装摄像头，但跟节点没有父节点了，所以就得给跟节点额外安装一个摄像头！
    """
    def minCameraCover(self, root: Optional[TreeNode]) -> int:
        # 0：有覆盖，1：无覆盖，2：有摄像头
        def traverse(root):
            if root is None:
                return 0  # 叶子节点的左右子节点（None）返回有覆盖，这样叶子节点就会是情况1返回无覆盖，摄像头就会安装到叶子节点的父节点上
            l = traverse(root.left)
            r = traverse(root.right)
            nonlocal ans
            if l == 0 and r == 0:  # 情况1：左右子节点都有覆盖，则父节点无覆盖
                return 1
            elif l == 1 or r == 1:  # 情况2：左右子节点有一个无覆盖，则父节点需要放摄像头
                ans += 1  # 摄像头数+1
                return 2
            elif l == 2 or r == 2:  # 情况3：左右子节点至少有一个摄像头，则父节点有覆盖（注：这里直接写else也可以！）
                return 0

        ans = 0
        if traverse(root) == 1:  # 如果根节点无覆盖，则需要往根节点额外放一个摄像头来覆盖根节点
            ans += 1
        return ans









