from typing import *


class Solution:
    """
    动态规划：复杂度O(n^2)，但很好想
    dp数组含义：dp[i]表示到i需要的最小步数
    初始化：dp[0] = 0因为一开始就在下标0，不用跳
    状态转移：对于每个位置i，我们遍历所有前面的下标j，如果从j能到i就更新一次（从j跳到i和当前的最小值比较）。

    """
    def jump(self, nums: List[int]) -> int:
        n = len(nums)
        dp = [float('inf')] * n
        dp[0] = 0
        for i in range(1, n):
            for j in range(i - 1, -1, -1):  # 遍历当前位置前面所有的位置
                if j + nums[j] >= i:
                    dp[i] = min(dp[i], dp[j] + 1)  # 如果跳到j的最小步数+1（即从j跳1步到1）小于当前最小的步数，则更新
        return dp[-1]

    """
    贪心：还是只看范围不看具体从哪开始跳，贪心思路是用最少的步数找到最大的范围。
    思想：假设在初始位置最远能跳x步，那么这x步内任意一个下标都只需要一步。我们的目标是选择跳到这x步之内的某个下标使得下一次跳的距离最大，
    但是具体选哪个很困难，所以我们就直接遍历统计这x步内最远能到哪，下一步终点就到哪。也就是说我们只考虑下一步最远能到哪，而不考虑从哪起跳，
    因为当前能到的最远距离之内任意一个都能一步跳到，所以我们只需要考虑当前能跳到的这些地方能够到的最远的位置，也就是下一步的目标跳跃终点。
    于是，我们遍历数组，边更新当前能到的最远范围（curr_max），边记录上一次跳跃的终点（last），一开始last=0意思是上一次我们跳到了0，即从
    0出发。
    
    例子：[2,3,1,1,4]
    从0起跳最远到2，也就是说在0起跳我们跳到2及之前的所有位置都行，算1步。那下一步跳跃最远到哪呢？于是我们遍历的时候就更新curr_max，在到达上一次跳跃最远能到的地方（2）时，
    我们就更新下一步跳跃所能到达的最远处（4），即我们跳到了2及之前的某个位置，从这个位置再跳一下最远能跳到4。
    
    last其实叫jump_start更好，即起跳位置；一开始从0起跳，下一次起跳位置是上一次起跳时的curr_max。（见hot100）
    """
    def jump1(self, nums: List[int]) -> int:
        last = 0  # 上一次（能）跳跃到的终点（的最大值），也就是说我们我们在last及last之前会跳跃一步
        curr_max = 0  # 当前最远能到哪，一开始curr_max=0哪都到不了
        ans = 0
        for i in range(len(nums) - 1):  # 因为last表示跳ans步能到的最远位置，且如果i就是终点了就不用跳了，所以i只遍历到终点前一步就可以了（防止i为终点时last恰好也是终点多跳一步）
            curr_max = max(curr_max, i + nums[i])
            if i == last:  # 此时last表示上一次跳跃（即跳到了last及last之前的某个位置）所能到达的最远位置，此时还没到终点，所以需要再跳
                ans += 1  # 每次更新完：curr_max表示跳ans步能到的最远位置
                last = curr_max  # 更新last，此时last就是此次跳跃所能到达的最远位置，也就是此时的ans步能到达的最远位置
        return ans





if __name__ == '__main__':
    sol = Solution()
    nums = [2,3,1,1,4]
    print(sol.jump(nums))


