from typing import *



"""
每次取n的最右边1位，左移对应的位数，一直累加即可。因为是固定32位，所以最右边1位左移31位，倒数第二位左移30位，以此类推。
例子：0011
1. 最右边的1左移3位：1000
2. 倒数第二个1左移2位，并累加：1000 + 100 = 1100 （注意，短的是靠右，其实是1000 + 0100）
3. 倒数第三个0左移1位，并累加：1100 + 00 = 1100
4. 倒数第四个0左移0位，并累加：1100 + 0 = 1100

注意：ans += (n & 1) << i也可以用ans |= (n & 1) << i。
|=是bitwise OR，因为本题每次每次过来的位是不同的位，所以|=不会出现两个相同位置都是1的情况。
如果两个数相同位置都是1，那么|=就不会进位，只会进行OR操作，就会出问题，但本题因为每次只看1位，不会重叠，所以不会有问题。
例子：
110 |= 001 = 111 = 7，6 |= 1 = 7。此时没有两位都是1，所以和+=一样。
101 |= 111 = 111 = 7，5 |= 7 = 7。此时有两位都是1的，所以和+=不一样。
"""
class Solution:
    def reverseBits(self, n: int) -> int:
        ans = 0
        for i in range(31, -1, -1):
            ans += (n & 1) << i  # 每次取最右边的一位，左移到对应位置
            n >>= 1  # 去掉最后一位，即右移1位
        return ans

    """
    更少的写法：每次右移i位然后&1，也就是说从右往左每次取最后一位，然后左移(31-i)位加到ans上
    """
    def reverseBits1(self, n: int) -> int:
        ans = 0
        for i in range(32):
            ans += ((n >> i) & 1) << (31 - i)
        return ans

